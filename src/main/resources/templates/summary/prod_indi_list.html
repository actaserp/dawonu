<html layout:decorate="~{layout_page}">
<th:block layout:fragment="content">
<div class="layout-contents">

    <div class="page-title-wrap">
        <div class="left">
            <h2>재고회전율 추이분석</h2>
            <a title="북마크" class="bookmark toggle">
                내 메뉴
            </a>
        </div>
        <ul class="page-navi">
            <li><img src="/images/icon/ico-nav-home.svg" alt="홈아이콘"></li>
            <li>KPI 성과 지표</li>
            <li>재고회전율 추이분석</li>
        </ul>
    </div>


    <section class="section">
        <div class="section-top">
            <div class="search-wrap">
                <dl>
                    <dt>
                        <label for="cboYear">
                            기준년도
                        </label>
                    </dt>
                    <dd>
                        <div class="srch-box">
                            <select id="cboYear">
                            </select>
                        </div>
                    </dd>
                </dl>

                <dl>
                    <dt>&nbsp;</dt>
                    <dd>
                        <li>
                            <a class="btn btn-delete" title="검색" id="btnSearch">
                                <!--                                        class 쓰이는 곳 찾고 없으면 클래스명 수정하기-->
                                <img src="/images/icon/btn-srch.svg" alt="검색 아이콘">
                                검색
                            </a>
                        </li>

                    </dd>
                </dl>

                <dl>
                    <dt>&nbsp;</dt>
                    <dd>
                        <li>
                            <span>
                            </span>
                        </li>

                    </dd>
                </dl>


            </div>
        </div>
        <div class="container-fluid">
            <div id="theGrid" style="height: 730px;"></div>
        </div>
    </section>
</div>
</th:block>
<th:block layout:fragment="scripts">
<script type="text/javascript">
    class ProductionMonthPage {
        constructor() {
            this.grid = null;
            this.viewData = new wijmo.collections.CollectionView();
            this.init();
        }

        /*init() {
            let _this = this;

            this.grid = new wijmo.grid.FlexGrid('#theGrid', {
                selectionMode: wijmo.grid.SelectionMode.Row,
                headersVisibility: wijmo.grid.HeadersVisibility.Column,
                allowSorting: wijmo.grid.AllowSorting.MultiColumn,
                allowMerging: wijmo.grid.AllowMerging.Cells,  //셀 병합
                autoGenerateColumns: false,
                showMarquee: true,
                isReadOnly: true,
                frozenColumns: 7,
                formatItem: (sender, e) => {
                    if (e.panel.cellType === wijmo.grid.CellType.ColumnHeader) {
                        e.cell.style.textAlign = 'center';
                    }
                },

                columns: [
                    { binding: 'mat_grp_name', header: '제품그룹', width: 100 ,allowMerging: true },
                    { binding: 'mat_code', header: '제품코드', width: 150 ,allowMerging: true },
                    { binding: 'mat_name', header: '제품명', width: 150 ,allowMerging: true },
                    { binding: 'unit_name', header: '단위', width: 70 , allowSorting: false },
                    { binding: 'year_qty_sum', header: '연수주량', width: 100, format: 'n0', align: 'right' },
                    { binding: 'year_money_sum', header: '연수주액', width: 150, format: 'n0', align: 'right' },
                    { binding: 'company_name', header: '업체', width: 200, allowSorting: false  },
                    ...Array.from({ length: 12 }, (_, i) => ({
                        binding: `mon_${i + 1}`,
                        header: `${i + 1}월`,
                        width: 80,
                        format: 'n0',
                        align: 'right',
                        allowSorting: false
                    }))
                ],
                itemsSource: this.viewData, // 데이터를 설정할 배열
            });
            this.grid.itemFormatter = function (panel, row, col, cell) {
                if (panel.cellType === wijmo.grid.CellType.Cell) {
                    let colName = panel.columns[col].binding;
                    let rowData = panel.rows[row]?.dataItem;
                    const prevRowData = panel.rows[row - 1]?.dataItem;

                    if (colName === 'gubn') {
                        const val = panel.getCellData(row, col, true);
                        const label = val === '1' ? '생산수량' : val === '2' ? '영업일수' : val === '3' ? '시간당생산량' : '';
                        cell.textContent = label;
                        cell.style.textAlign = 'center';
                    }

                    if (colName.startsWith('mon_') && rowData?.gubn) {
                        let value = panel.getCellData(row, col, false);
                        let gubn = rowData.gubn;

                        if (typeof value === 'number') {
                            cell.textContent = gubn === '3'
                                ? wijmo.Globalize.format(value, 'n2')
                                : wijmo.Globalize.format(value, 'n0');
                        }

                        cell.style.textAlign = 'right';
                    }

                    if (['mat_type_name', 'mat_grp_name', 'mat_code', 'unit_name', 'standard1'].includes(colName)) {
                        cell.style.textAlign = 'center';          // 수평 가운데
                        cell.style.verticalAlign = 'middle';      // 수직 가운데
                        cell.style.display = 'flex';              // flex로 정렬
                        cell.style.alignItems = 'center';         // 수직 정렬
                        cell.style.justifyContent = 'center';     // 수평 정렬
                    } else if (['mat_name']){
                        cell.style.textAlign = 'left';
                        cell.style.verticalAlign = 'middle';      // 수직 가운데
                        cell.style.display = 'flex';              // flex로 정렬
                        cell.style.alignItems = 'center';         // 수직 정렬
                        cell.style.justifyContent = 'left';     // 수평 정렬
                    }
                }
            };
            new FlexGridContextMenu(this.grid);
            this.grid.downloadFileName = '생산량 지표';
            this.grid.mergeManager = new CustomMergeManager(this.grid);
        }*/

        init() {
            let _this = this;

            this.grid = new wijmo.grid.FlexGrid('#theGrid', {
                selectionMode: wijmo.grid.SelectionMode.Row,
                headersVisibility: wijmo.grid.HeadersVisibility.Column,
                allowSorting: false,
                autoGenerateColumns: false,
                isReadOnly: true,
                frozenColumns: 4,
                allowMerging: wijmo.grid.AllowMerging.All,
                columns: [
                    { binding: 'mat_grp_name', header: '제품그룹', width: 120, allowMerging: true },
                    { binding: 'mat_code', header: '제품코드', width: 140, align: 'center', allowMerging: true },
                    { binding: 'mat_name', header: '제품명', width: 240, align: 'center', allowMerging: true },
                    { binding: 'unit_name', header: '단위', width: 80, align: 'center', allowMerging: true },
                    ...Array.from({ length: 12 }, (_, i) => ([ // 월별 1~12월
                        { binding: `mon_${i + 1}_money`, header: '매출액', width: 120, align: 'center', format: 'n0' },
                        { binding: `mon_${i + 1}_avginv`, header: '평균재고금액', width: 100, align: 'center', format: 'n0' },
                        { binding: `mon_${i + 1}_turnover`, header: '재고회전율', width: 120, align: 'center', format: 'n2' }
                    ])).flat(),
                    { binding: 'year_turnover', header: '연간 재고회전율', width: 140, align: 'center', format: 'n2' } // ✅ 맨 마지막
                ],
                itemsSource: _this.viewData
            });

            // ✅ 2단 헤더 생성
            const topRow = new wijmo.grid.Row();
            this.grid.columnHeaders.rows.insert(0, topRow);
            let colIndex = 4;

            for (let month = 1; month <= 12; month++) {
                const col1 = this.grid.columns[colIndex];
                const col2 = this.grid.columns[colIndex + 1];
                const col3 = this.grid.columns[colIndex + 2];
                this.grid.columnHeaders.setCellData(0, colIndex, `${month}월`);
                this.grid.columnHeaders.setCellData(0, colIndex + 1, `${month}월`);
                this.grid.columnHeaders.setCellData(0, colIndex + 2, `${month}월`);
                col1.header = '매출액';
                col2.header = '평균재고금액';
                col3.header = '재고회전율(횟수)';
                colIndex += 3;
            }

            this.grid.allowMerging = wijmo.grid.AllowMerging.All;
            this.grid.columnHeaders.rows[0].allowMerging = true;
            this.grid.columnHeaders.rows[1].allowMerging = false;

            // ✅ 푸터 행 추가
            this.grid.columnFooters.rows.push(new wijmo.grid.GroupRow());
            this.grid.bottomLeftCells.setCellData(0, 0, '합계');

            // ✅ 푸터 계산 함수
            const updateFooter = () => {
                const cv = this.grid.collectionView;
                const footer = this.grid.columnFooters;
                if (!cv || !footer) return;

                for (let month = 1; month <= 12; month++) {
                    const moneyKey = `mon_${month}_money`;
                    const invKey = `mon_${month}_avginv`;
                    const turnKey = `mon_${month}_turnover`;

                    const totalMoney = cv.items.reduce((sum, item) => sum + (parseFloat(item[moneyKey]) || 0), 0);
                    const totalInv = cv.items.reduce((sum, item) => sum + (parseFloat(item[invKey]) || 0), 0);
                    const turnover = totalInv ? (totalMoney / totalInv) : 0;

                    footer.setCellData(0, moneyKey, totalMoney);
                    footer.setCellData(0, invKey, totalInv);
                    footer.setCellData(0, turnKey, turnover.toFixed(2));
                }
            };

            // ✅ 데이터 로드 / 갱신 후 푸터 갱신
            this.grid.collectionView.collectionChanged.addHandler(updateFooter);
            this.grid.updatedView.addHandler(updateFooter);

            // ✅ 셀 스타일
            this.grid.itemFormatter = function (panel, row, col, cell) {
                if (panel.cellType === wijmo.grid.CellType.Cell) {
                    cell.style.textAlign = 'center';
                    cell.style.verticalAlign = 'middle';
                    const val = cell.textContent?.trim();
                    if (!val || val === 'null' || val === 'undefined') cell.textContent = '';
                }

                // 푸터 색상/강조
                if (panel.cellType === wijmo.grid.CellType.ColumnFooter) {
                    cell.style.backgroundColor = '#f0f0f0';
                    cell.style.fontWeight = 'bold';
                    cell.style.textAlign = 'center';
                }
            };

            new FlexGridContextMenu(this.grid);
            this.grid.downloadFileName = '월별_재고회전율';
        }








        searchMainData() {
            let url = '/api/summary/indicator/prod_read'
            let data = {
				'cboYear' : $("#cboYear").val(),
                'spjangcd' : sessionStorage.getItem('spjangcd')
			}
            const result = AjaxUtil.getSyncData(url, data);
            console.log("result data : ", result.data);
            if (result.success) {

                /*let rows = result.data;

                const expandedRows = [];
                rows.forEach(item => {
                    // 매출원가 행
                    // 매출원가 행
                    expandedRows.push({
                        ...item,
                        rowType: '매출원가',
                        displayName: item.mat_name,
                        unit_name: item.unit_name,
                        mat_code: item.mat_code,
                        ...Object.fromEntries(
                            Object.entries(item)
                                .filter(([k]) => k.includes('_money'))
                                .map(([k, v]) => [k.replace('_money', ''), v])
                        )
                    });

                    // 평균단가 행
                    expandedRows.push({
                        ...item,
                        rowType: '평균단가',
                        displayName: '평균단가',
                        unit_name: item.unit_name,
                        mat_code: item.mat_code,
                        ...Object.fromEntries(
                            Object.entries(item)
                                .filter(([k]) => k.includes('_avg_price'))
                                .map(([k, v]) => [k.replace('_avg_price', ''), v])
                        )
                    });
                });
                this.grid.itemsSource = expandedRows;
*/

                this.grid.itemsSource = result.data;
            }else{
                Alert.alert('', '에러가 발생하였습니다.');
            }
        }

    }

    let page = null;

    $(document.body).ready(function (e) {
        page = new ProductionMonthPage();

        AjaxUtil.fillSelectOptions($('#cboYear'), 'data_year', '', false);

        page.searchMainData();

        // 검색
        $('#btnSearch').click(function (e) {
            page.searchMainData();
        });
    });

    class CustomMergeManager extends wijmo.grid.MergeManager {
        getMergedRange(panel, row, col, clip = true) {
            if (panel.cellType !== wijmo.grid.CellType.Cell) {
                return super.getMergedRange(panel, row, col, clip);
            }

            const colName = panel.columns[col].binding;
            if (colName === 'standard1' || colName === 'unit_name') {
                const matNameCol = panel.columns.getColumn('mat_name').index;
                const val = panel.getCellData(row, col, false);
                const matName = panel.getCellData(row, matNameCol, false);

                let rng = new wijmo.grid.CellRange(row, col);

                // 위로 병합
                while (rng.row > 0) {
                    let prevVal = panel.getCellData(rng.row - 1, col, false);
                    let prevMatName = panel.getCellData(rng.row - 1, matNameCol, false);
                    if (prevVal !== val || prevMatName !== matName) break;
                    rng.row--;
                }

                // 아래로 병합
                while (rng.row2 < panel.rows.length - 1) {
                    let nextVal = panel.getCellData(rng.row2 + 1, col, false);
                    let nextMatName = panel.getCellData(rng.row2 + 1, matNameCol, false);
                    if (nextVal !== val || nextMatName !== matName) break;
                    rng.row2++;
                }

                return rng.isSingleCell ? null : rng;
            }

            return super.getMergedRange(panel, row, col, clip);
        }
    }



</script>
</th:block>